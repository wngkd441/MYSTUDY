# 21317. 징검다리 건너기

## 문제

심마니 영재는 산삼을 찾아다닌다.

산삼을 찾던 영재는 *N*개의 돌이 일렬로 나열되어 있는 강가를 발견했고, 마지막 돌 틈 사이에 산삼이 있다는 사실을 알게 되었다.

마지막 돌 틈 사이에 있는 산삼을 캐기 위해 영재는 돌과 돌 사이를 점프하면서 이동하며 점프의 종류는 3가지가 있다.

점프의 종류에는 현재 위치에서 다음 돌로 이동하는 작은 점프, 1개의 돌을 건너뛰어 이동하는 큰 점프, 2개의 돌을 건너뛰어 이동하는 매우 큰 점프가 있다.

각 점프를 할 때는 에너지를 소비하는데, 이 때 작은 점프와 큰 점프시 소비되는 에너지는 점프를 하는 돌의 번호마다 다르다.

매우 큰 점프는 단 한 번의 기회가 주어지는데, 이때는 점프를 하는 돌의 번호와 상관없이 *k*만큼의 에너지를 소비한다.

에너지를 최대한 아껴야 하는 영재가 산삼을 얻기 위해 필요한 에너지의 최솟값을 구하여라.

영재는 첫 번째 돌에서부터 출발한다.



### 입력

첫 번째 줄에는 돌의 개수 *N*이 주어진다.

*N* - 1개의 줄에 걸쳐서, 1번 돌부터 *N* - 1번 돌 까지의 작은 점프를 하기 위해 필요한 에너지, 큰 점프를 하기 위해 필요한 에너지가 주어진다.

마지막 줄에는 *K*가 주어진다.

### 출력

산삼을 얻기 위해 필요한 영재의 최소 에너지를 출력한다.

### 제한

- 1 ≤ *N* ≤ 20
- 작은 점프, 큰 점프 시 필요한 에너지와 *K*는 5,000을 넘지않는 자연수이다.



## 예제

### 입력 1

```python
5
1 2
2 3
4 5
6 7
4
```

### 출력 1

```python
5
```



## 코드

```python
rocks = int(input())  # 돌의 개수
s_jumps, l_jumps = [0] * (rocks - 1), [0] * (rocks - 1)
for _ in range(rocks - 1):
    s_jumps[_], l_jumps[_] = map(int, input().split())  # 작은 점프, 큰 점프
ll_jump = int(input())  # 매우 큰 점프

# DP
dp = [123456789] * rocks  # 최대값으로 초기화한 dp 배열
dp[0] = 0

# 작은 점프 + 큰 점프 최소 에너지 구하기
for i in range(rocks - 1):
    # 작은 점프 되는지
    if i + 1 < rocks:
        dp[i + 1] = min(dp[i + 1], dp[i] + s_jumps[i])
    # 큰 점프 되는지
    if i + 2 < rocks:
        dp[i + 2] = min(dp[i + 2], dp[i] + l_jumps[i])

# 매우 큰 점프 최소 에너지 구하기
ans = dp[-1]
for j in range(rocks - 3):  # 매우 큰 점프를 넣어보고 계산할 위치
    n_dp = dp[:]
    n_dp[j + 3] = dp[j] + ll_jump
    for k in range(j + 3, rocks - 1):
        # 작은 점프 되는지
        if k + 1 < rocks:
            n_dp[k + 1] = min(n_dp[k + 1], n_dp[k] + s_jumps[k])
        # 큰 점프 되는지
        if k + 2 < rocks:
            n_dp[k + 2] = min(n_dp[k + 2], n_dp[k] + l_jumps[k])
    # 기존 dp와 비교
    ans = min(ans, n_dp[-1])
print(ans)
```
