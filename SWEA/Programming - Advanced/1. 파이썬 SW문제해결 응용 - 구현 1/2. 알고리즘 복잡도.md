# 1. 알고리즘

## 알고리즘

- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법.
- 주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법.
- 어떠한 문제를 해결하기 위한 절차.
- Ex. 1부터 100까지의 합을 구하는 문제
  1. 1부터 100까지 차례로 더함.
  2. 101 × 50.





# 2. 효율성

## 알고리즘의 효율

- 입력의 크기가 커질수록 알고리즘의 효율에 따라 실행 시간의 차이 발생.
- 알고리즘을 설계하면, 실행에 필요한 자원의 양을 분석하여 효율성을 나타냄.
- 공간적 효율성: 얼마나 많은 메모리 공간을 요하는가?
- 시간적 효율성: 얼마나 많은 시간을 요하는가?
- 효율성은 복잡도로 표현 가능. 복잡도가 높을수록 효율성 저하.

- 시간도 복잡도 분석
  - 하드웨어 환경에 따라 처리시간 달라짐.
    - 부동소수 처리 프로세서 존재 유무.
    - 나눗셈 가속 가능 유무.
    - 입출력 장비의 성능과 공유 여부.
  - 소프트웨어 환경에 따라 처리시간 달라짐.
    - 프로그램 언어 종류.
    - 운영체제 종류.
    - 컴파일러 종류.
  - 환경적 차이로 인해 분석 어려움.





# 3. 점근적 표기

## 시간(또는 공간) 복잡도의 점근적 표기

- 입력 크기에 대한 함수로 표기.
- 단순한 함수로 표현하기 위해 점근적 표기 사용.
- 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법.
  - O(Big\-Oh) 표기
  - Ω(Big\-Omega) 표기
  - Θ(Theta) 표기



## 점근적 상한

### O(Big\-Oh) 표기

- 복잡도의 점근적 상한을 나타냄.

- 복잡도가 f(n) = 2n^2 \- 7n \+ 4라면, f(n)의 O\-표기는 O(n^2).

- f(n)의 단순화된 표현은 n^2(다항식의 최고차항의 계수).

- 단순화된 함수에 임의의 상수 c를 곱한 cn^2이 n이 증가함에 따라 f(n)의 상한이 됨. 이때, c는 양수.

- '최악의 경우에, 이만큼 시간이 걸린다.'

- O(g(n))이 점근적 상한이라는 것은 n_0보다 큰 모든 n에 대해서 항상 f(n)보다 크다는 것을 의미.

- 자주 사용하는 O\-표기

  아래로 내려갈수록 많은 시간 소요.

  - O(1): 상수 시간
  - O(logn): 로그 시간
  - O(n): 선형 시간
  - O(nlogn): 로그 선형 시간
  - O(n^2): 제곱 시간
  - O(n^3): 세제곱 시간
  - O(2^n): 지수 시간



## 점근적 하한

### Ω(Big\-Omega) 표기

- 복잡도의 점근적 하한을 나타냄.
- 복잡도가 f(n) = 2n^2 \- 7n \+ 4라면, f(n)의 Ω\-표기는 Ω(n^2).
- f(n)의 단순화된 표현은 n^2(다항식의 최고차항의 계수).
- f(n)=Ω(n^2)은 n이 증가함에 따라 2n^2 \- 7n \+ 4가 cn^2보다 작을 수 없다라는 의미로, 상수 c=1로 놓으면 됨.
- '최소한 이만한 시간은 걸린다.'
- Ω(g(n))이 점근적 하한이라는 것은 n_0보다 큰 모든 n에 대해서 항상 f(n)보다 작다는 것을 의미.



## 점근적 상한과 하한이 동일

### Θ(Theta) 표기

- O\-표기와 Ω\-표기가 같은 경우 사용.
- f(n) = 2n^2 \- 7n \+ 4 = O(n^2) = Ω(n^2)이므로, f(n) = Θ(n^2).
- f(n)은 n이 증감함에 따라 n^2과 동일한 증가율을 가진다는 것을 의미.





# 4. 효율적 알고리즘의 필요성

- Ex. 10억 개의 숫자를 정렬
  - O(n^2) 알고리즘은 300여 년 걸림.
  - O(nlogn) 알고리즘은 5분 걸림.

- 즉, 효율적인 알고리즘은 슈퍼컴퓨터보다 더 큰 가치가 있음.
- 값비싼 HW의 기술 개발보다 효율적인 알고리즘 개발이 더 경제적.