2차원 List
	1차원 List를 묶어놓은 List
	2차원 이상의 다차원 List는 차원에 따라 Index를 선언
	2차원 List의 선언: 세로길이(행의 개수), 가로길이(열의 개수)를 필요로 함
	파이썬에서는 데이터 초기화를 통해 변수선언과 초기화 가능.

List 초기화
	arr = [0,0,0,0,0]
	arr = [0] * 5
	arr = [i for i in range(2,9) if i%2 ==0] # [2,4,6,8]

	brr = [[1,2,3],[1,2,3],[1,2,3]]
	brr = [[1,2,3]] * 3
	brr = [[1,2,3] for i in range(3)] # [[1,2,3],[1,2,3],[1,2,3]]
	brr = [[i,j] for i in range(3) for j in range(2)] # [[0,0],[0,1],[1,0],[1,1],[2,0],[2,1]]

2차원 List 입력 받기
	첫째 줄에 n행 m열, 둘째 줄부터 n*m의 행렬 데이터가 주어질 경우 입력받는 방법
		ex1.
		n,m = map(int, input().split())
		mylist = [0 for _ in range(n)] # mylist = [0]*n
		for i in range(n): mylist[i] = list(map(int, input().split())
		ex2.
		n,m = map(int, input().split())
		mylist = []
		for i in range(n): mylist.append(list(map(int,input(0.split()))
		ex3.
		n,m = map(int, input().split())
		mylist = [list(map(int, input().split())) for _ in range(n)]

2차원 List에서 원하는 데이터의 위치 찾기
		n,m = map(int, input().split())
		mylist = [list(map(int, input().split())) for _ in range(n)]
		newlist = [(i,j) for i in range(n) for j in range(m) if mylist[i][j] == 1]

List 순회
	n*m list의 n*m개의 모든 원소를 빠짐없이 조사하는 방법
	1. 행 우선 순회
		List의 행을 우선으로 List의 원소를 조사하는 방법
		이중반복문으로 구현 가능
		for i in range(len(arr)):
			for j in range(len(arr[i])):
				arr[i][j] # 필요한 연산 수행
	2. 열 우선 순회
		List의 열부터 먼저 조사하는 방법
		이중반복문으로 구현하지만 행과 열의 위치 바꿔서
		for j in range(len(arr[0])):
			for i in range(len(arr)):
				arr[i][j] # 필요한 연산 수행
	3. 지그재그 순회
		List의 행을 좌우로 조사하는 방법
		--->
		<---
		--->
		순회방향에 따라 index값이 커지거나 작아져야 함
		for i in range(len(arr)):
			for j in range(len(arr[0])):
				arr[i][j+(m-1-2*j)*(i%2)] # 필요한 연산 수행

델타를 이용한 2차 List 탐색
	2차 List의 한 좌표에서 네 방향의 인접 List 요소를 탐색할 때 사용하는 방법
	델타 값은 한 좌표에서 네 방향의 좌표와 x, y의 차이를 저장한 List 구현
	델타 값을 이용하여 특정 원소의 상화좌우에 위치한 원소에 접근할 수 있음.
	이차원 List의 가장자리 원소들은 상하좌우 네 방향에 원소가 존재하지 않을 경우가 있으므로, Index를 체크하거나 Index의 범위를 제한해야 함.
	dx = [0, 0, -1, 1], dy = [-1, 1, 0, 0]
	for i in range(4):
		testX = x + dx[i]
		testY = y + dy[i]
		print(arr[testX][testY])

전치 행렬
	행과 열의 값이 반대인 행렬을 의미
	for i in range(3):
		for j in range(3):
			if i<j: arr[i][j], arr[j][i] = arr[j][i], arr[i][j]

	이때 모든 좌표에 대하여 행과 열의 값을 바꾸게 되면 본래의 모습으로 되돌아오기 때문에 이를 주의해야 함.

zip(iterable *) 함수
	동일한 개수로 이루어진 자료형들을 tuple로 묶어 주는 역할을 하는 함수.
	자료형의 개수가 다르면 자료형의 개수가 작은 쪽의 크기의 원소까지 묶어줌.
	zip 함수의 인자로 리스트를 행별로 쪼개서 사용할 수 있음.
	아스테리크(*) 리스트명 (ex. zip(*arr))은 리스트를 행별로 분리하는 역할을 하고 분리된 리스트를 zip함수의 인자로 넣으면 여러 개의 자료형을 넣은 것처럼 slice하여 묶어진 결과를 얻을 수 있음.
	ex.
	arr = [[1,2,3], [4,5,6], [7,8,9]]
	print(list(zip(*arr)))
	>>> [(1,4,7), (2,5,8), (3,6,9)]
	따라서, zip(*matrix) : 전치행렬
