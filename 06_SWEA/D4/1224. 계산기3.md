# 1224. 계산기3

## 문제

문자열로 이루어진 계산식이 주어질 때, 이 계산식을 후위 표기식으로 바꾸어 계산하는 프로그램을 작성하시오.

예를 들어

“3+(4+5)*6+7”

라는 문자열로 된 계산식을 후위 표기식으로 바꾸면 다음과 같다.

"345+6*+7+"

변환된 식을 계산하면 64를 얻을 수 있다.

문자열 계산식을 구성하는 연산자는 +, * 두 종류이며 문자열 중간에 괄호가 들어갈 수 있다.

이 때 괄호의 유효성 여부는 항상 옳은 경우만 주어진다.

피연산자인 숫자는 0 ~ 9의 정수만 주어진다.



### 입력

각 테스트 케이스의 첫 번째 줄에는 테스트 케이스의 길이가 주어진다. 그 다음 줄에 바로 테스트 케이스가 주어진다.

총 10개의 테스트 케이스가 주어진다.

### 출력

\#부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 답을 출력한다.





## 예제

### 입력 1

```
113
(9+(5*2+1)+(3*3*7*6*9*1*7+1+8*6+6*1*1*5*2)*4*7+4*3*8*2*6+(7*8*4*5)+3+7+(2+6+5+1+7+6+7*3*(6+2)+6+6)*2+4+2*2+4*9*3)
85
(4+8+4*(8*5*(7*(6*8)+3+(6+(3+7+1*7*5*4)*3)*2*3+5)+6+7*7)*4+2+9*4+7+2*3*(7*6*1*8)+9+9)
97
(9*5+7+8+6+3+9*2+1+7+4+3+9*3*1+4*(4+4*3*1+9*3+(9*5)*1*7*8+2+8+8*7+9*4*9)+(1+1*8+8*9*7+1*4*5*2*5))
89
((3*1*4+6*3+8+4+5+4+2*1+5+3*4)*1+1+(3*2*2+9+5*4*6*9+9+4+1*8+9)*4*8+9+3*7+9*6*9*5+8+3*8+1)
125
(2+(6*5+6+5+3*9+6+2+8*2+2)+6+2*2+2*5*1*2+1*8+1*(4+7*5+8+9+7+3*8*5)+(2+9+5*4*4+1+3*9*6*4*5+(5*(3+4)*9+8+7+9*2)+7+7+2)+8+2+7+5)
113
(8+8*6+3*9*8*7*6*3+5*(7*6*6+3*5+2*4*9*3+5+2+1*4)*1*7+6*8+9+3+2+8*3+8*(2+6*9+2*2*7+8*1*2+9*3+1+5)*(5*8+4*1*2*4*2))
115
(7+9*2+6+5*7+1*7*(9+8+6)*1*2+7+5*9*6*3+4*8*9*6*1*3+7*1+2+5+1*4*9+6*4+7*1*2*4*2+3+((3*4+9+7*1+7+5+3*7*1*7+8*3*8)+7))
99
(9*4+(1+5*7*8+9+1+2)+5+(6*(7+4*5*2+4+8*4+7)+9)*1*3*1+1*2*8+3+(2+9*(1*5*9+7*1+1+7+3*2))+1+3*7*8+9*6)
75
(2*2+((7+8*8*6+(6*6)*7+7*1)*5)*7+3+1*5+1*8*4+(9+6+(7*5+3+1*8*8*9+4+7+9)*3))
117
(8+6*9+2*3+4+2+(6+9+3+7*5*1+2+2+2)*9+4+6*1+6*4+7+7*2+5+2*6*(8*9*8*6+4*2)*5+5*8*3+(6+1+3+3*8*1*2*1+5+6)+1+5+4*7*1*3+1)
```

### 출력 1

```
#1 672676
#2 1974171
#3 12654
#4 38756
#5 4035
#6 155304
#7 6964
#8 2819
#9 24711
#10 208785
```





## 코드

```python
# Testcase
T = 10
# 연산자
opt_in = ['(', '+', '*', ')']
opt_come = [')', '+', '*', '(']
for tc in range(1, T+1):
    # 계산식의 길이
    s_len = int(input())
    # 계산식
    s = list(input().rstrip())
    stack = [] # 스택
    temp = [] # 출력용
    while s:
        token = s.pop(0)
        if token not in opt_come: # 피연산자
            temp.append(token)
        else: # 연산자
            if token == ')': # 오른쪽 괄호면
                # 왼쪽 괄호를 만날 때까지 pop 하여 출력
                while stack[-1] != '(':
                    temp.append(stack.pop(-1))
                stack.pop(-1) # 왼쪽 괄호는 pop만
            # top의 연산자보다 우선순위가 높거나 top에 연산자가 없으면
            elif not stack or opt_come.index(token) > opt_in.index(stack[-1]):
                stack.append(token) # push
            else: # 그렇지 않다면
                # top의 우선순위가 토큰의 우선순위가 작을 때까지
                while stack and opt_come.index(token) <= opt_in.index(stack[-1]):
                    temp.append(stack.pop(-1)) # pop하여 출력
                stack.append(token)
    # 문자열 다 읽은 후엔 스택을 pop하여 출력
    while stack:
        temp.append(stack.pop(-1))
    # 계산
    calc = [] # 계산용 스택
    ans = 0 # 계산 결과값
    while temp:
        now = temp.pop(0)
        if now not in opt_in: # 피연산자면
            calc.append(int(now))
        else: # 연산자면
            # 마지막 두개로 계산
            if now == '+':
                ans = calc.pop(-2) + calc.pop(-1)
            else:
                ans = calc.pop(-2) * calc.pop(-1)
            calc.append(ans) # 다시 스택에 저장
    # 결과값 출력
    print(f'#{tc} {calc[-1]}')
```
