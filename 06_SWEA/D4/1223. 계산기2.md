# 1223. 계산기2

## 문제

문자열로 이루어진 계산식이 주어질 때, 이 계산식을 후위 표기식으로 바꾸어 계산하는 프로그램을 작성하시오.

예를 들어

“3+4+5*6+7”

라는 문자열로 된 계산식을 후위 표기식으로 바꾸면 다음과 같다.

"34+56*+7+"

변환된 식을 계산하면 44를 얻을 수 있다.

문자열 계산식을 구성하는 연산자는 +, * 두 종류이며 피연산자인 숫자는 0 ~ 9의 정수만 주어진다.



### 입력

각 테스트 케이스의 첫 번째 줄에는 테스트 케이스의 길이가 주어진다. 그 다음 줄에 바로 테스트 케이스가 주어진다.

총 10개의 테스트 케이스가 주어진다.

### 출력

\#부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 답을 출력한다.





## 예제

### 입력 1

```
101
9+5*2+1+3*3*7*6*9*1*7+1+8*6+6*1*1*5*2*4*7+4*3*8*2*6+7*8*4*5+3+7+2+6+5+1+7+6+7*3*6+2+6+6*2+4+2*2+4*9*3
79
4+4*3*4*9+2+7*4*7+7*7*9*5*2+8*8+2*6*7*3*7*9*3*4+8+8*9+3+9+6+9+4*1+6*3+5+1+7+5*1
113
2+3+9*9+8+2*1+3*2*3*1+3*3+1+2+3*6*2*7*4+9+1+4+6+9*9*5+7+8+6+3+9*2+1+7+4+3+9*3*1+4*4+4*3*1+9*3+9*5*1*7*8+2+8+8*7+9
89
4*9+1+1*8+8*9*7+1*4*5*2*5+8*3*5+5+2*4+2+8+6*2*2+9+3*1*2+2*5+9*2*3*9+6+7*9+9*4+7+6+6*6+3+8
77
5+4+9+9*9*2+6*6*5+9+3*5+5*7*8*3*7*1*9*9+8+3+8*9*6+2*9*3+6*5+6*7*2+5+5*3+4*6+7
119
5+7+1+6+3+6*7+7+5*5*3*5*6*9+5*9*5*9+8+8+5*1*6*2+3+2+8+6+2+2*3*4+5*8*3*6*2*9+1*7*7*4*2+2*5+6+7+2*7*4+9*6*4*3*1*3*5+3*7+8
115
8*6+3*9*8*7*6*3+5*7*6*6+3*5+2*4*9*3+5+2+1*4*1*7+6*8+9+3+2+8*3+8*2+6*9+2*2*7+8*1*2+9*3+1+5*5*8+4*1*2*4*2*6*3*8*8+4+1
91
5*8*4+5*7+9*2+6+5*7+1*7*9+8+6*1*2+7+5*9*6*3+4*8*9*6*1*3+7*1+2+5+1*4*9+6*4+7*1*2*4*2+3+3*4+9
107
7*1+7+5+3*7*1*7+8*3*8+7+3*2*6*2+3+6*4+3+8+9*4+1+5*7*8+9+1+2+5+6*7+4*5*2+4+8*4+7+9*1*3*1+1*2*8+3+2+9*1*5*9+7
109
1+1+7+3*2+1+3*7*8+9*6+1+8*3*7+8*5*7*7+4*3*7*4+7+3+2*2+7+8*8*6+6*6*7+7*1*5*7+3+1*5+1*8*4+9+6+7*5+3+1*8*8*9+4+7
```

### 출력 1

```
#1 28134
#2 195767
#3 4293
#4 1592
#5 477326
#6 45647
#7 102951
#8 6548
#9 1394
#10 4285
```





## 코드

```python
# Testcase
T = 10
# 연산자
opt_in = ['(', '+', '*', ')']
opt_come = [')', '+', '*', '(']
for tc in range(1, T+1):
    # 계산식의 길이
    s_len = int(input())
    # 계산식
    s = list(input().rstrip())
    stack = [] # 스택
    temp = [] # 출력용
    while s:
        token = s.pop(0)
        if token not in opt_come: # 피연산자
            temp.append(token)
        else: # 연산자
            if token == ')': # 오른쪽 괄호면
                # 왼쪽 괄호를 만날 때까지 pop 하여 출력
                while stack[-1] != '(':
                    temp.append(stack.pop(-1))
                stack.pop(-1) # 왼쪽 괄호는 pop만
            # top의 연산자보다 우선순위가 높거나 top에 연산자가 없으면
            elif not stack or opt_come.index(token) > opt_in.index(stack[-1]):
                stack.append(token) # push
            else: # 그렇지 않다면
                # top의 우선순위가 토큰의 우선순위가 작을 때까지
                while stack and opt_come.index(token) <= opt_in.index(stack[-1]):
                    temp.append(stack.pop(-1)) # pop하여 출력
                stack.append(token)
    # 문자열 다 읽은 후엔 스택을 pop하여 출력
    while stack:
        temp.append(stack.pop(-1))
    # 계산
    calc = [] # 계산용 스택
    ans = 0 # 계산 결과값
    while temp:
        now = temp.pop(0)
        if now not in opt_in: # 피연산자면
            calc.append(int(now))
        else: # 연산자면
            # 마지막 두개로 계산
            if now == '+':
                ans = calc.pop(-2) + calc.pop(-1)
            else:
                ans = calc.pop(-2) * calc.pop(-1)
            calc.append(ans) # 다시 스택에 저장
    # 결과값 출력
    print(f'#{tc} {calc[-1]}')
```
