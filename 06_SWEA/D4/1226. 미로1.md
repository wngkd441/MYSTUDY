# 1226. 미로1

## 문제

아래 그림과 같은 미로가 있다. 16*16 행렬의 형태로 만들어진 미로에서 흰색 바탕은 길, 노란색 바탕은 벽을 나타낸다.

가장 좌상단에 있는 칸을 (0, 0)의 기준으로 하여, 가로방향을 x 방향, 세로방향을 y 방향이라고 할 때, 미로의 시작점은 (1, 1)이고 도착점은 (13, 13)이다.

주어진 미로의 출발점으로부터 도착지점까지 갈 수 있는 길이 있는지 판단하는 프로그램을 작성하라.

아래의 예시에서는 도달 가능하다.
 

 ![img](https://swexpertacademy.com/main/common/fileDownload.do?downloadType=CKEditorImages&fileId=AV2XYayaDcQBBASl) 


아래의 예시에서는 출발점이 (1, 1)이고, 도착점이 (11, 11)이며 도달이 불가능하다.

![img](https://swexpertacademy.com/main/common/fileDownload.do?downloadType=CKEditorImages&fileId=AV2XYev6DcUBBASl)



### 입력

각 테스트 케이스의 첫 번째 줄에는 테스트 케이스의 번호가 주어지며, 바로 다음 줄에 테스트 케이스가 주어진다.

총 10개의 테스트케이스가 주어진다.

테스트 케이스에서 1은 벽을 나타내며 0은 길, 2는 출발점, 3은 도착점을 나타낸다.

### 출력

\#부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 도달 가능 여부를 1 또는 0으로 표시한다 (1 - 가능함, 0 - 가능하지 않음).





## 예제

### 입력 1

```
1
1111111111111111
1210000000100011
1010101110101111
1000100010100011
1111111010101011
1000000010101011
1011111110111011
1010000010001011
1010101111101011
1010100010001011
1010111010111011
1010001000100011
1011101111101011
1000100000001311
1111111111111111
1111111111111111
2
1111111111111111
1200000010000011
1011111011111011
1000001010000011
1110101010111011
1010101010100011
1011111010111111
1000001010000011
1011101011111011
1010101010000011
1010101010111111
1010100000130011
1010111111111011
1000000000000011
1111111111111111
1111111111111111
3
1111111111111111
1210001000100011
1010101010101011
1000100010101011
1011111110101011
1000001010101011
1111101010101011
1010001000001011
1010111111111011
1010000000100011
1011111110101111
1000001010100011
1011101010111011
1000100000130011
1111111111111111
1111111111111111
4
1111111111111111
1200100000000011
1011101110111011
1000001010101011
1111111011101011
1000100010000011
1010101010111111
1010001010001011
1011111011101011
1000100010100011
1110101110111111
1010100000130011
1010111111111011
1000000000000011
1111111111111111
1111111111111111
5
1111111111111111
1210000000100011
1010111011101011
1010100010001011
1011101010111011
1000001010001011
1111111011111011
1000100010000011
1011101010111011
1010001000001011
1010101011111111
1010101000000011
1010101110111011
1000100010001311
1111111111111111
1111111111111111
6
1111111111111111
1210001010000011
1010101010111111
1010100000100011
1010111111101011
1000100000001011
1110101111111011
1000100000001011
1011101111101011
1000101000101011
1110101010111011
1010100010100011
1010111110101111
1000000000100311
1111111111111111
1111111111111111
7
1111111111111111
1210000000000011
1011101111111011
1000101010000011
1110101010111011
1000001000101011
1010111111101111
1010100000100011
1011101110101111
1000001000100011
1111111011111011
1000100010001011
1010101110111011
1010001300000011
1111111111111111
1111111111111111
8
1111111111111111
1200000010000011
1111111010111011
1000000010001011
1011111111111011
1010000000000011
1010111111101011
1010000000001011
1010111011111011
1000100010001011
1111111011101011
1000001000100011
1110111110101011
1000000000101311
1111111111111111
1111111111111111
9
1111111111111111
1200000000001011
1011111111101011
1000000010001011
1111111010111011
1000100010000011
1011101111111011
1010001000001011
1010111011101011
1010000010101311
1011111110101111
1000100000100011
1011101011111011
1000001000000011
1111111111111111
1111111111111111
10
1111111111111111
1200001000100011
1111101110101011
1000100010001011
1011101111101111
1000100000000011
1110111111101011
1000000010001011
1110111011101011
1010001000001011
1010101111111011
1000101010000011
1010101010101111
1010100000100311
1111111111111111
1111111111111111
```

### 출력 1

```
#1 1
#2 1
#3 1
#4 0
#5 1
#6 1
#7 0
#8 1
#9 1
#10 1
```





## 코드

```python
from collections import deque


# Testcase
T = 10
for _ in range(1, T+1):
    # Testcsae num
    tc = int(input())
    # 미로 입력
    size = 16
    maze = [[] for _ in range(size)]
    for _ in range(size):
        maze[_] = list(map(int, input()))
        if 2 in maze[_]:
            start = (_, maze[_].index(2))
        if 3 in maze[_]:
            end = (_, maze[_].index(3))
    # 이동방향: 우하좌상
    dr = [0, 1, 0, -1]
    dc = [1, 0, -1, 0]
    # 큐
    queue = deque()
    queue.append(start)
    # 방문 기록
    visited = [[0 for _ in range(size)] for _ in range(size)]
    # 결과값
    result = 0
    # bfs
    while queue:
        now = queue.popleft()
        if maze[now[0]][now[1]] == 3: # 도착점에 도착
            result = 1
            break
        for d in range(4): # 4 방향
            nr = now[0] + dr[d]
            nc = now[1] + dc[d]
            if 0 <= nr < size and 0 <= nc < size: # 범위 안일 때
                if not visited[nr][nc] and maze[nr][nc] != 1: # 벽이 아니고 방문한 곳이 아닐 때
                    visited[nr][nc] = 1
                    queue.append((nr, nc))
    # Result
    print(f'#{tc} {result}')
```
